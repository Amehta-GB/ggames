'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _rc = require('rc');

var _rc2 = _interopRequireDefault(_rc);

var _shelljs = require('shelljs');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const conf = (0, _rc2.default)('NJM', {
  PATH: `${ __dirname }/../.njm`,
  NEO4J_RELEASE: '3.0.3',
  NEO4J_EDITION: 'community',
  NEO4J_HTTP: '0.0.0.0:7474',
  NEO4J_HOST: 'http://dist.neo4j.org'
});

exports.default = (opt = {}) => {
  let instances = {};

  const {
    path = conf.PATH,
    http = conf.NEO4J_HTTP,
    release = conf.NEO4J_RELEASE,
    edition = conf.NEO4J_EDITION
  } = opt;

  const makeDir = p => (0, _shelljs.test)('-d', p) || (0, _shelljs.mkdir)(p);
  const batch = fn => Object.keys(instances).map(fn);
  const sourceFile = v => `neo4j-${ edition }-${ v }-unix.tar.gz`;
  const command = cmd => name => {
    if (!name) return batch(command(cmd));
    instances[name] && instances[name][cmd]();
    if ('destroy' === cmd) delete instances[name];
  };

  const stop = command('stop');
  const start = command('start');
  const restart = command('restart');
  const destroy = command('destroy');
  const instance = name => name ? instances[name] : instances;
  const create = (name, options) => {

    if (instances[name]) instances[name].destroy();
    const file = sourceFile(options && options.release || release);
    const instancePath = `${ path }/instances/${ name }`;
    const tempPath = `${ path }/temp/${ name }`;
    (0, _utils.fetch)(conf.NEO4J_HOST, file, path);
    (0, _shelljs.rm)('-rf', instancePath);
    makeDir(tempPath);
    (0, _shelljs.exec)(`tar -zxvf ${ path }/neo4j/${ file } -C ${ tempPath }/`);
    (0, _shelljs.mv)('-f', `${ tempPath }/${ file }`.replace('-unix.tar.gz', ''), instancePath);
    (0, _shelljs.rm)('-rf', `${ tempPath }/`);
    instances[name] = createInstance(name, instancePath, _extends({ http }, options));
  };

  makeDir(path);
  makeDir(`${ path }/temp/`);
  makeDir(`${ path }/neo4j/`);
  makeDir(`${ path }/instances/`);

  (0, _utils.dirs)(`${ path }/instances`).map(name => {
    const instancePath = `${ path }/instances/${ name }`;
    const file = _fs2.default.readFileSync(`${ instancePath }/conf/neo4j.conf`, 'utf8');
    if (instances[name]) return;
    instances[name] = createInstance(name, instancePath, false);
  });

  return { create, start, stop, restart, destroy, instance };
};

function createInstance(name, path, options) {
  const command = cmd => () => {
    if (!(0, _shelljs.test)('-d', path)) throw new Error('Invalid instance');
    (0, _shelljs.exec)(`${ path }/bin/neo4j ${ cmd }`);
  };
  const start = command('start');
  const stop = command('stop');
  const restart = command('restart');
  const destroy = () => {
    if ((0, _shelljs.test)('-e', `${ path }/run/neo4j.pid`)) stop();
    (0, _shelljs.rm)('-rf', path);
  };

  const setup = (props = {}) => {
    let file = _fs2.default.readFileSync(`${ path }/conf/neo4j.conf`, 'utf8');
    let _props = (0, _utils.parse)((0, _utils.get)(file));

    if (props) {
      if (props.http) {
        if (!isNaN(props.http)) {
          _props.http.port = parseInt(props.http);
        } else {
          _props.http = (0, _utils.parse)(props.http);
        }
      }

      if (props.https) {
        if (!isNaN(props.https)) {
          _props.https.port = parseInt(props.https);
        } else {
          _props.https = (0, _utils.parse)(props.https);
        }
      } else {
        _props.https.port = _props.http.port + 1;
      }

      if (props.bolt) {
        if (!isNaN(props.bolt)) {
          _props.bolt.port = parseInt(props.bolt);
        } else {
          _props.bolt = (0, _utils.parse)(props.bolt);
        }
      } else {
        _props.bolt.port = _props.http.port - 1;
      }
    }

    file = (0, _utils.set)(file, (0, _utils.format)(_props));
    (0, _shelljs.exec)(`rm -rf ${ path }/conf/neo4j.conf`);
    _fs2.default.writeFileSync(`${ path }/conf/neo4j.conf`, file);

    return _extends({}, (0, _utils.get)(file), { setup, start, stop, destroy, restart });
  };

  return setup(options);
}